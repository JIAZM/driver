<font face=simsun size=4>

# Linux网络子系统

1. 应用层socket编程回顾

2. 网络嗅探工具wireshark使用

3. 网络协议栈概述
    - 网络协议模型 以太网帧格式  
        OSI七层模型  
        TCP/IP四层模型  
        TCP/IP五层模型  
        ![网络协议模型](./网络协议模型.png)  
    ***<u>TCP/IP 协议栈在内核中 ！</u>***
    
4. DM9000驱动分析
    > 程序路径在 linux-4.15/drivers/net/ethernet/davicom/dm9000.c  

    - 最外层platform架构分析
    ```C
    static struct platform_driver dm9000_driver = {
        .driver = {
            .name    = "dm9000",
            .pm  = &dm9000_drv_pm_ops,
            .of_match_table = of_match_ptr(dm9000_of_matches),
        },   
        .probe   = dm9000_probe,
        .remove  = dm9000_drv_remove,
    };
    ```
    在内核代码中使用grep全局搜索 "\"dm9000\""找到设备注册路径./arch/arm/mach-s3c24xx/mach-mini2440.c
    ```C
    // 设备结构体定义
    static struct platform_device mini2440_device_eth = { 
        .name       = "dm9000",
        .id     = -1, 
        .num_resources  = ARRAY_SIZE(mini2440_dm9k_resource),
        .resource   = mini2440_dm9k_resource,
        .dev        = {
            .platform_data  = &mini2440_dm9k_pdata,
        },  
    };

    // 在平台设备数组中加入设备结构体地址
    static struct platform_device *mini2440_devices[] __initdata = {
        ...
        &mini2440_device_eth,
        ...
    }

    // 
    static void __init mini2440_init(void)
    {
        ...
        platform_add_devices(mini2440_devices, ARRAY_SIZE(mini2440_devices));
        /*
         * @ platform_add_devices - add a numbers of platform devices
         * 
         * int platform_add_devices(struct platform_device **devs, int num)
         * {
         *     ...
         *     for(i = 0; i < num; i++){
         *         ret = platform_device_register(devs[i]);
         *         ...
         *     }
         *     ...
         * }
         */
        ...
    }
    ```
    ***dm9000设备资源 ./arch/arm/mach-s3c24xx/mach-mini2440.c***
    ```C
    static struct resource mini2440_dm9k_resource[] = {     // 两个内存资源 一个是地址接口，另一个是数据接口
        // 内存资源
        [0] = DEFINE_RES_MEM(MACH_MINI2440_DM9K_BASE, 4),   // MACH_MINI2440_DM9K_BASE  (S3C2410_CS4 + 0x300)
        /*
         * #define DEFINE_RES_MEM(_start, _size)    DEFINE_RES_MEM_NAMED((_start), (_size), NULL)
         *    #define DEFINE_RES_MEM_NAMED(_start, _size, _name)    DEFINE_RES_NAMED((_start), (_size), (_name), IORESOURCE_MEM)
                #define DEFINE_RES_NAMED(_start, _size, _name, _flags)          \
                    {                                       \
                        .start = (_start),                  \
                        .end = (_start) + (_size) - 1,      \
                        .name = (_name),                    \
                        .flags = (_flags),                  \
                        .desc = IORES_DESC_NONE,            \
                    }
         */
        // [0] = DEFINE_RES_MEM(MACH_MINI2440_DM9K_BASE, 4)
        // ---> DEFINE_RES_MEM_NAMED((MACH_MINI2440_DM9K_BASE), (4), NULL)
        // ---> DEFINE_RES_NAMED((MACH_MINI2440_DM9K_BASE), (4), (NULL), IORESOURCE_MEM)
        /*
            {
                .start = (MACH_MINI2440_DM9K_BASE),
                .end = (MACH_MINI2440_DM9K_BASE) + (4) - 1,
                .name = (NULL),
                .flags = (IORESOURCE_MEM),
                .desc = IORES_DESC_NONE,
            }
        */

        // 内存资源
        [1] = DEFINE_RES_MEM(MACH_MINI2440_DM9K_BASE + 4, 4),

        // IRQ资源
        [2] = DEFINE_RES_NAMED(IRQ_EINT7, 1, NULL, IORESOURCE_IRQ \
                            | IORESOURCE_IRQ_HIGHEDGE),
        /*
            {
                .start = (IRQ_EINT7),
                .end = (IRQ_EINT7) + (1) - 1,
                .name = (NULL),
                .flags = (IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE),
                .desc = IORES_DESC_NONE,
            }
        */
    };
    ```
    - 驱动初始化
        > drivers/net/ethernet/davicom/dm9000.c
        ```C
            module_platform_driver(dm9000_driver);
            // #define module_platform_driver(__platform_driver)   \
            //                module_driver(__platform_driver, platform_driver_register, platform_driver_unregister)
            
            /*
                #define module_driver(__driver, __register, __unregister, ...) \
                static int __init __driver##_init(void) \
                { \
                    return __register(&(__driver) , ##__VA_ARGS__); \
                } \
                module_init(__driver##_init); \
                static void __exit __driver##_exit(void) \
                { \
                    __unregister(&(__driver) , ##__VA_ARGS__); \
                } \
                module_exit(__driver##_exit);
            */

            // module_platform_driver(dm9000_driver);
            // ---> module_driver(dm9000_driver, platform_driver_register, platform_driver_unregister)
            /* --->
                static int __init dm9000_driver_init(void)
                {
                    return platform_driver_register(&(dm9000_driver) , __VA_ARGS__);
                }
                module_init(dm9000_driver_init);

                static void __exit dm9000_driver_exit(void)
                {
                    platform_driver_unregister(&(dm9000_driver) , __VA_ARGS__);
                }
                module_exit(dm9000_driver_exit);
            */
        ```
        ***<u>platform平台总线设备驱动，匹配成功后调用prob函数,在probe函数中完成真正的注册与初始化</u>***
    - ***<u>probe()函数分析</u>***  

        ```C
        static int dm9000_probe(struct platform_device *pdev)
        {
            struct dm9000_plat_data *pdata = dev_get_platdata(&pdev->dev);

            // board_info定义的是板子的信息 在dm9000.c中定义 
            struct board_info *db;  /* Point a board information structure */
            /*
                struct board_info(
                    void __iomem *io_addr;  // Register I/O base address
                    void __iomem *io_data;  // Data I/O address
                    u16 irq;
                    ...
                    void (*inblk)(void __iomem *port, void *data, int length);
                    void (*outblk)(void __iomem *port, void *data, int length);
                    void (*dumpblk)(void __iomem *port, int length);
                    
                    struct device *dev; // 基类

                    // 资源描述结构体
                    struct resource *addr_res;
                    struct resource *data_res;
                    struct resource *addr_req;
                    struct resource *data_req;
                    ...
                )
            */
            struct net_device *ndev;    // 表示一个网卡设备，系统中有多少个网卡设备就会有多少个net_device结构体描述网卡
            ...
            // 1. 申请 struct net_device 与 struct board_info 结构体
            /* Init network device */
            ndev = alloc_etherdev(sizeof(struct board_info));
            ...
            /* setup board info structure */
            db = netdev_priv(ndev);
            ...
            // 2. 从platform_device获取资源，包括 1)得到表示dm9000 data和address的地址，并建立映射之后，代表data和address的内存才可以使用
            db->addr_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
            db->data_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
            ...
            db->irq_wake = platform_get_irq(pdev, 1);
            ...
            // 
            iosize = resource_size(db->addr_res);
            /*
                static inline resource_size_t resource_size(const struct resource *res)
                {
                    return res->end - res->start + 1;   
                }
            */
            db->addr_req = request_mem_region(db->addr_res->start, iosize, pdev->name);
            // 判断资源地址是否已经被使用，若已经被使用则返回空，否则将这段地址标记为已使用
            // 防止不同的驱动同时使用相同的地址
            // 若成功执行 addr_req == addr_res & data_req == data_res
            ...

            // 完成内存映射 CPU使用虚拟地址访问设备
            db->io_addr = ioremap(db->addr_res->start, iosize);
            // 访问DM9000 实际使用的是io_add 这个虚拟地址，CPU只能使用虚拟地址！
            ...
            // 与addr相同的方式将data地址映射到虚拟地址
            iosize = resource_size(db->data_res);
            db->data_req = request_mem_region(db->data_res->start, iosize, pdev->name);
            ...
            db->io_data = ioremap(db->data_res->start, iosize);
            // CPU 使用io_addr 与io_data访问dm9000网卡
            ...
            // 3. 根据情况设定board 的读写函数
            /* ensure at least we have a default set of IO routines */
            dm9000_set_io(db, iosize);  // 根据不同的size大小对db中的 dumpblk outblk inblk操作函数进行赋值，但是没有意义
            // 后续的程序根据pdata中的内容对操作函数进行设置
            /* check to see if anything is being over-ridden */
            if (pdata != NULL) {
                ...
            }
            /*
                struct dm9000_plat_data *pdata = dev_get_platdata(&pdev->dev);
                static inline void *dev_get_platdata(const struct device *dev)
                {
                    return dev->platform_data;
                }
                @ padta = pdev->dev->platform_data;
                    具体内容见 arch/arm/mach-s3c24xx/mach-mini2440.c中dm9000 device结构体
            */
            ...
            // 4. 对网卡进行软件重启
            dm9000_reset(db);   // 通过操作dm9000寄存器实现
            /*
                static void iow(struct board_info *db, int reg, int value)
                {
                    writeb(reg, db->io_addr);
                    writeb(value, db->io_data);
                }

                static u8 ior(struct board_info *db, int reg)
                {
                    writeb(reg, db->io_addr);
                    return readb(db->io_data);
                }
            */
            ...
            // 5. 读取并验证网卡的vendor id和device id
            for (i = 0; i < 8; i++) {
                id_val  = ior(db, DM9000_VIDL);
                id_val |= (u32)ior(db, DM9000_VIDH) << 8;
                id_val |= (u32)ior(db, DM9000_PIDL) << 16;
                id_val |= (u32)ior(db, DM9000_PIDH) << 24;
            
                if (id_val == DM9000_ID)
                    break;
                dev_err(db->dev, "read wrong id 0x%08x\n", id_val);
            }
            ...
            id_val = ior(db, DM9000_CHIPR);
            ...
            switch (id_val) {   // 验证的动作
            case CHIPR_DM9000A:
                db->type = TYPE_DM9000A;
                break;
            case CHIPR_DM9000B:
                db->type = TYPE_DM9000B;
                break;
            default:
                dev_dbg(db->dev, "ID %02x => defaulting to DM9000E\n", id_val);
                db->type = TYPE_DM9000E;
            }
            ...
            // 6. 读取网卡的chip revision并根据不同的revision赋值
            // 见具体内核代码
            ...
            // 7. 开始初始化net_device，设计到很多网卡硬件细节
            // 定义 fops
            ndev->netdev_ops    = &dm9000_netdev_ops;
            ndev->ethtool_ops   = &dm9000_ethtool_ops;  // 支持上层的ethtool工具
            /*
                static const struct net_device_ops dm9000_netdev_ops = {
                    .ndo_open       = dm9000_open,
                    .ndo_stop       = dm9000_stop,
                    .ndo_start_xmit     = dm9000_start_xmit,
                    .ndo_tx_timeout     = dm9000_timeout,
                    .ndo_set_rx_mode    = dm9000_hash_table,
                    .ndo_do_ioctl       = dm9000_ioctl,
                    .ndo_set_features   = dm9000_set_features,
                    .ndo_validate_addr  = eth_validate_addr,
                    .ndo_set_mac_address    = eth_mac_addr,
                #ifdef CONFIG_NET_POLL_CONTROLLER
                    .ndo_poll_controller    = dm9000_poll_controller,
                #endif
                };
                static const struct ethtool_ops dm9000_ethtool_ops = {       
                    .get_drvinfo        = dm9000_get_drvinfo,
                    .get_msglevel       = dm9000_get_msglevel,
                    .set_msglevel       = dm9000_set_msglevel,
                    .nway_reset     = dm9000_nway_reset,
                    .get_link       = dm9000_get_link,  
                    .get_wol        = dm9000_get_wol,   
                    .set_wol        = dm9000_set_wol,   
                    .get_eeprom_len     = dm9000_get_eeprom_len,
                    .get_eeprom     = dm9000_get_eeprom,
                    .set_eeprom     = dm9000_set_eeprom,
                    .get_link_ksettings = dm9000_get_link_ksettings,
                    .set_link_ksettings = dm9000_set_link_ksettings, 
                };
            */
            // 设置 mac 地址
            if (!is_valid_ether_addr(ndev->dev_addr) && pdata != NULL) {
                mac_src = "platform data";
                memcpy(ndev->dev_addr, pdata->dev_addr, ETH_ALEN);
                // 将 pdata->dev_addr中的数据设为mac地址
            }
            ...
            // 8. register_netdev注册网卡设备
            platform_set_drvdata(pdev, ndev);
            ret = register_netdev(ndev);
            ...
        }
        ```
    - 网卡驱动的发送过程
    - 网卡驱动的接收过程
5. Linux loopback驱动详解
   
6. 主讲Linux TCP/IP协议栈和网卡驱动 《深入理解Linux网络技术内幕》









</font>